<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode-108-将有序数组转换为二叉搜索树</title>
    <url>/2020/07/03/Leetcode-108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
</blockquote>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/jqBhmOkZ1zJHNxR.png" alt=""></p>
<h1 id="二分思路"><a href="#二分思路" class="headerlink" title="二分思路"></a>二分思路</h1><p>将数组中最中间的元素作为根结点构建二叉树, 并递归构建左右子树即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = buildBST(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = buildBST(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/qjRwvlW2XFdk1yI.png" alt=""></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-112-路径总和</title>
    <url>/2020/07/07/Leetcode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200707083143487.png" alt="image-20200707083143487"></p>
<p>返回 <code>true</code>, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p>
</blockquote>
<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><p>很简单, 直接左右子树进行判断, 然后对布尔量求逻辑或即可. 注意边界条件, 在<code>root==null</code>的时候, 说明没有该路径, 返回<code>false</code>.</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum - root.val == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200707083332173.png" alt="image-20200707083332173"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-120-三角形最小路径和</title>
    <url>/2020/07/14/Leetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p>
<p>例如，给定三角形：</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200714105032667.png" alt="image-20200714105032667"></p>
<p>自顶向下的最小路径和为 <code>11</code>（即，<strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11）。</p>
</blockquote>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>假设<code>dp[i][j]</code>是处于位置<code>(i, j)</code>时的最小路径总和.</p>
<p>由于位置<code>(i, j)</code>只能从位置<code>(i-1,j-1)</code>和位置<code>(i-1, j)</code>过来, 那么可以很容易的知道动态转移方程为:</p>
<script type="math/tex; mode=display">
dp[i][j]=min(dp[i-1][j-1], dp[i-1][j])+triange[i][j]</script><p><strong><code>dp</code>初始化</strong></p>
<p>对<code>dp</code>所有元素初始赋值为<code>Integer.MAX_VALUE</code>, 方便进行比较最小值.</p>
<p>需要注意的是, <code>dp[i][0]</code>只能从上方转移, 所以初始化的时候需要另外处理.</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = triangle.get(i).get(<span class="number">0</span>) + dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[n - <span class="number">1</span>][j] &lt; min) &#123;</span><br><span class="line">                min = dp[n - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     System.out.println(Arrays.toString(dp[i]));</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200714105910433.png" alt="image-20200714105910433"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1504-统计全1子矩阵</title>
    <url>/2020/07/07/Leetcode-1504-%E7%BB%9F%E8%AE%A1%E5%85%A81%E5%AD%90%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给你一个只包含 0 和 1 的 rows * columns 矩阵 mat ，请你返回有多少个 子矩形 的元素全部都是 1 。</p>
<p>示例 1：</p>
<p>输入：mat = [[1,0,1],<br>            [1,1,0],<br>            [1,1,0]]<br>输出：13<br>解释：<br>有 6 个 1x1 的矩形。<br>有 2 个 1x2 的矩形。<br>有 3 个 2x1 的矩形。<br>有 1 个 2x2 的矩形。<br>有 1 个 3x1 的矩形。<br>矩形数目总共 = 6 + 2 + 3 + 1 + 1 = 13 。<br>示例 2：</p>
<p>输入：mat = [[0,1,1,0],<br>            [0,1,1,1],<br>            [1,1,1,0]]<br>输出：24<br>解释：<br>有 8 个 1x1 的子矩形。<br>有 5 个 1x2 的子矩形。<br>有 2 个 1x3 的子矩形。<br>有 4 个 2x1 的子矩形。<br>有 2 个 2x2 的子矩形。<br>有 2 个 3x1 的子矩形。<br>有 1 个 3x2 的子矩形。<br>矩形数目总共 = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24 。<br>示例 3：</p>
<p>输入：mat = [[1,1,1,1,1,1]]<br>输出：21<br>示例 4：</p>
<p>输入：mat = [[1,0,1],[0,1,0],[1,0,1]]<br>输出：5</p>
<p>提示：</p>
<p>1 &lt;= rows &lt;= 150<br>1 &lt;= columns &lt;= 150<br>0 &lt;= mat[i][j] &lt;= 1</p>
</blockquote>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h2><p>用<code>dp[i][j]</code>来表示从<code>mat[i][0]</code>到<code>mat[i][j]</code>最多有多少个连续的<code>1</code>. 动态转移方程为:</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200707104214289.png" alt="image-20200707104214289"></p>
<p>而临界值<code>dp[i][0]</code>则等于<code>mat[i][0]</code>.</p>
<p>比如下面的矩阵中, <code>dp[3][2]=3, dp[2][2]=2, dp[1][2]=3, dp[0][2]=1</code></p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200707101543387.png" alt="image-20200707101543387"></p>
<h2 id="计算思路"><a href="#计算思路" class="headerlink" title="计算思路"></a>计算思路</h2><p>对于每一个元素<code>mat[i][j]</code>, 我们将其当作一个矩阵的右下角来计算他能组成的矩阵数目.</p>
<p>比如, 对于元素<code>mat[3][2]</code>, 以其作为矩阵的右下角, 只考虑<strong>最后一行</strong>(从0开始数, 第3行, 下同)所构成的矩阵, 他能构成的矩阵为三个, 如图所示.</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200707102219981.png" alt="image-20200707102219981"></p>
<p>然后考虑由<strong>第2, 3行</strong>构成的, 以<code>mat[3][2]</code>为右下角的矩阵, 有两个, 如图所示.</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200707102407898.png" alt="image-20200707102407898"></p>
<p>然后考虑由<strong>第1, 2, 3行</strong>构成的, 以<code>mat[3][2]</code>为右下角的矩阵, 也是有两个, 如图所示.</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200707102615699.png" alt="image-20200707102615699"></p>
<p>最后, 由<strong>第0, 1, 2, 3行</strong>构成的, 以<code>mat[3][2]</code>为右下角的矩阵, 有一个, 如图所示.</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200707102709427.png" alt="image-20200707102709427"></p>
<p>也就是说, 照着以上步骤的对矩阵<code>mat</code>中的每一个元素进行一遍以上的运算, 然后计算矩阵数的总和即可.</p>
<p>那么, 最后还有一个问题. 以元素<code>mat[i][j]</code>为右下角的矩阵能构成的个数是怎么计算的呢?</p>
<p>由上面的步骤可以轻松看出来, 对于元素<code>mat[i][j]</code>, 计算<code>k</code>到<code>i</code>行构成的矩阵数目时, 该数目等于<code>dp[k..i][j]</code>的最小值, 也就是连续为1的数量的最小值. 如图所示, 因为最小值为1, 所以可以构建的矩阵个数为1.</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200707103723429.png" alt="image-20200707103723429"></p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubmat</span><span class="params">(<span class="keyword">int</span>[][] mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.length, n = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp初始化</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = mat[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历每一个元素, 计算矩阵个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// mat[i][j]为0时, dp[i][j]直接置零, 说明在此位置没有连续1</span></span><br><span class="line">                <span class="keyword">if</span> (mat[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    min = Math.min(min, dp[k][j]);</span><br><span class="line">                    sum += min;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200707103759951.png" alt="image-20200707103759951"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-174-地下城游戏</title>
    <url>/2020/07/12/Leetcode-174-%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>一些恶魔抓住了公主（<strong>P</strong>）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（<strong>K</strong>）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为<em>负整数</em>，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 <em>0</em>），要么包含增加骑士健康点数的魔法球（若房间里的值为<em>正整数</em>，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
<p><strong>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</strong></p>
<p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 <code>右 -&gt; 右 -&gt; 下 -&gt; 下</code>，则骑士的初始健康点数至少为 <strong>7</strong>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>-2 (K)</th>
<th>-3</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>-5</td>
<td>-10</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>30</td>
<td>-5 (P)</td>
</tr>
</tbody>
</table>
</div>
<p><strong>说明:</strong></p>
<ul>
<li>骑士的健康点数没有上限。</li>
<li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li>
</ul>
</blockquote>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>此处需要按照<strong>从右下角到左上角</strong>的顺序进行动态规划.</p>
<p>假设<code>dp[i][j]</code>为在位置<code>(i, j)</code>到终点所需要的最小起始生命值. 假设<code>dp[i+1][j]</code>和<code>dp[i][j+1]</code>是已知的, 那么<code>dp[i][j]</code>应该等于<code>dp[i+1][j]</code>和<code>dp[i][j+1]</code>的最小值, 再减去当前位置所要消耗的生命值<code>dungeon(i,j)</code>, 并且要注意, 初始生命值应该是大于等于1的. </p>
<p>根据上述描述可知, 动态转移方程为</p>
<script type="math/tex; mode=display">
dp[i][j]=max(min(dp[i+1][j], dp[i][j+1])-deungen(i, j), 1)</script><p>对于边界条件, 需要对<code>dp[n][m-1]</code>和<code>dp[n-1][m]</code>设置为1, 而<code>dp</code>其他位置则需要设置为<code>Integer.MAX_VALUE</code>.</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = dungeon.length, m = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[n][m - <span class="number">1</span>] = dp[n - <span class="number">1</span>][m] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                dp[i][j] = Math.max(<span class="number">1</span>, Math.min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]) - dungeon[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200713103520292.png" alt="image-20200713103520292"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1503-所有蚂蚁掉下来前的最后一刻</title>
    <url>/2020/07/07/Leetcode-1503-%E6%89%80%E6%9C%89%E8%9A%82%E8%9A%81%E6%8E%89%E4%B8%8B%E6%9D%A5%E5%89%8D%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%88%BB/</url>
    <content><![CDATA[<blockquote>
<p>有一块木板，长度为 n 个 单位 。一些蚂蚁在木板上移动，每只蚂蚁都以 每秒一个单位 的速度移动。其中，一部分蚂蚁向 左 移动，其他蚂蚁向 右 移动。</p>
<p>当两只向 不同 方向移动的蚂蚁在某个点相遇时，它们会同时改变移动方向并继续移动。假设更改方向不会花费任何额外时间。</p>
<p>而当蚂蚁在某一时刻 t 到达木板的一端时，它立即从木板上掉下来。</p>
<p>给你一个整数 n 和两个整数数组 left 以及 right 。两个数组分别标识向左或者向右移动的蚂蚁在 t = 0 时的位置。请你返回最后一只蚂蚁从木板上掉下来的时刻。</p>
<p>示例 1：</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/ants.jpg" alt="img"></p>
<p>输入：n = 4, left = [4,3], right = [0,1]<br>输出：4<br>解释：如上图所示：<br>-下标 0 处的蚂蚁命名为 A 并向右移动。<br>-下标 1 处的蚂蚁命名为 B 并向右移动。<br>-下标 3 处的蚂蚁命名为 C 并向左移动。<br>-下标 4 处的蚂蚁命名为 D 并向左移动。<br>请注意，蚂蚁在木板上的最后时刻是 t = 4 秒，之后蚂蚁立即从木板上掉下来。（也就是说在 t = 4.0000000001 时，木板上没有蚂蚁）。<br>示例 2：</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/ants2.jpg" alt="img"></p>
<p>输入：n = 7, left = [], right = [0,1,2,3,4,5,6,7]<br>输出：7<br>解释：所有蚂蚁都向右移动，下标为 0 的蚂蚁需要 7 秒才能从木板上掉落。<br>示例 3：</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/ants3.jpg" alt="img"></p>
<p>输入：n = 7, left = [0,1,2,3,4,5,6,7], right = []<br>输出：7<br>解释：所有蚂蚁都向左移动，下标为 7 的蚂蚁需要 7 秒才能从木板上掉落。<br>示例 4：</p>
<p>输入：n = 9, left = [5], right = [4]<br>输出：5<br>解释：t = 1 秒时，两只蚂蚁将回到初始位置，但移动方向与之前相反。<br>示例 5：</p>
<p>输入：n = 6, left = [6], right = [0]<br>输出：6</p>
<p>提示：</p>
<p>1 &lt;= n &lt;= 10^4<br>0 &lt;= left.length &lt;= n + 1<br>0 &lt;= left[i] &lt;= n<br>0 &lt;= right.length &lt;= n + 1<br>0 &lt;= right[i] &lt;= n<br>1 &lt;= left.length + right.length &lt;= n + 1<br>left 和 right 中的所有值都是唯一的，并且每个值 只能出现在二者之一 中。</p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>乍一看这题目很复杂, 但是其实只要转换一下思路, 不区分具体的蚂蚁, 其实碰撞之后掉头和直接穿过去的结果是一样的. 那么问题就变成了求最晚落地的蚂蚁所需要的时间. 也就是最晚落地蚂蚁所走过的路径长度.</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLastMoment</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left[i] &gt; max) max = left[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n - right[i] &gt; max) max = n - right[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200707084531723.png" alt="image-20200707084531723"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>脑筋急转弯</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-309-最佳买卖股票时机含冷冻期</title>
    <url>/2020/07/10/Leetcode-309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>示例:</p>
<p>输入: [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p>
</blockquote>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>使用<code>dp[i]</code>来表示第<code>i</code>天<strong>结束</strong>之后的<strong>累计最大收益</strong>. 因为题目中包含了冷冻期的概念, 所以可以用数组的第二维来表示第<code>i</code>天<strong>结束</strong>之后的状态.:</p>
<ul>
<li>第<code>i</code>天<strong>结束</strong>之后, 持有股票, 对应的<strong>累计最大收益</strong>为<code>dp[i][0]</code></li>
<li><p>第<code>i</code>天<strong>结束</strong>之后, 不持有股票, 处于<strong>冷冻期</strong>, 对应的<strong>累计最大收益</strong>为<code>dp[i][1]</code></p>
</li>
<li><p>第<code>i</code>天<strong>结束</strong>之后, 不持有股票, 不处于<strong>冷冻期</strong>, 对应的<strong>累计最大收益</strong>为<code>dp[i][2]</code></p>
</li>
</ul>
<p><strong>冷冻期</strong>的定义: 第<code>i</code>天处于冷冻期, 则第 <code>i+1</code>天不能买股票.</p>
<p>下面对三种状态进行分析:</p>
<ul>
<li><p>第<code>i</code>天<strong>结束</strong>之后, 持有股票, 对应的<strong>累计最大收益</strong>为<code>dp[i][0]</code>.</p>
<p>对于第<code>i</code>天结束之后持有的股票, 存在两种情况:</p>
<ol>
<li>是第<code>i</code>天购买的, 那么说明第<code>i-1</code>天不能持有股票, 且不处于冷冻期, 对应的<strong>累计最大收益</strong>为<code>dp[i-1][2]</code>, 还需要考虑到第<code>i</code>天买了股票, 产生了负收益<code>-prices[i]</code>, 那么该情况下的<strong>累计最大收益</strong>为<code>dp[i-1][2]-prices[i]</code></li>
<li>是第<code>i-1</code>天时就已经持有(注意, 不是购买)的股票, 那么对应的<strong>累计最大收益</strong>为<code>dp[i-1][0]</code></li>
</ol>
<p>第 <code>i</code>天结束后持有股票对应的<strong>累计最大收益</strong>为上述两种情况的较大者, 即</p>
<script type="math/tex; mode=display">
dp[i][0]=max(dp[i-1][0], f[i-1][2]-prices[i])</script></li>
<li><p>第<code>i</code>天<strong>结束</strong>之后, 不持有股票, 处于<strong>冷冻期</strong>, 对应的<strong>累计最大收益</strong>为<code>dp[i][1]</code></p>
<p>第<code>i</code>天结束之后, 不持有股票, 处于冷冻期, 说明了第<code>i</code>天刚卖出了股票, 对应的<strong>累计最大收益</strong>为前一天的<strong>累计最大收益</strong>加上今天卖出股票所获得的收益, 而前一天的<strong>累计最大收益</strong>是持有股票的情况, 即<code>dp[i-1][0]</code>. 总的来说, 就是</p>
<script type="math/tex; mode=display">
dp[i][1]=prices[i]+dp[i-1][0]</script></li>
<li><p>第<code>i</code>天<strong>结束</strong>之后, 不持有股票, 不处于<strong>冷冻期</strong>, 对应的<strong>累计最大收益</strong>为<code>dp[i][2]</code></p>
<p>第<code>i</code>天结束之后, 不持有股票, 不处于冷冻期, 说明这一天没有进行操作, 也说明了第<code>i-1</code>天没有持有股票:</p>
<ol>
<li>如果第<code>i-1</code>天不处于冷冻期, 对应的<strong>累计最大收益</strong>为<code>dp[i-1][1]</code></li>
<li>如果第<code>i-1</code>天处于冷冻期, 对应的<strong>累计最大收益</strong>为<code>dp[i-1][2]</code></li>
</ol>
<p>第<code>i</code>天的<strong>累计最大收益</strong>为</p>
<script type="math/tex; mode=display">
dp[i][2]=max(dp[i-1][1], dp[i-1][2])</script></li>
</ul>
<p>最后一天(n-1天)结束之后, <strong>累计最大收益</strong>为三种状态下的最大值.</p>
<script type="math/tex; mode=display">
max(dp[n-1][0], dp[n-1][1], dp[n-1][2])</script><p>然而比较<code>dp[n-1][0]</code>是没有意义的, 因为这说明最后一天结束的时候还持有股票. 也就是只要比较后面两种状态就可以了:</p>
<script type="math/tex; mode=display">
max(dp[n-1][1], dp[n-1][2])</script><p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[prices.length - <span class="number">1</span>][<span class="number">1</span>], dp[prices.length - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200710104014511.png" alt="image-20200710104014511"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-226 翻转二叉树</title>
    <url>/2020/05/06/Leetcode-226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>翻转一棵二叉树。</p>
<p>示例:</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/ngIbTYh1FryXZJD.png" alt=""></p>
<p>备注:<br>这个问题是受到 Max Howell 的<a href="https://twitter.com/mxcl/status/608682016205344768" target="_blank" rel="noopener">原问题</a>启发的 ：</p>
<blockquote>
<p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p>
</blockquote>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>直接递归翻转就可以了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 空树直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换当前结点的左右子树</span></span><br><span class="line">        TreeNode tmp = root.right;</span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归处理左右子树</span></span><br><span class="line">        root.left = invertTree(root.left);</span><br><span class="line">        root.right = invertTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回根结点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/1588736749671.png" alt="1588736749671"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>前序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-350-两个数组的交集Ⅱ</title>
    <url>/2020/07/13/Leetcode-350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%E2%85%A1/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p>示例 1:</p>
<p>输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>输出: [2,2]<br>示例 2:</p>
<p>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出: [4,9]<br>说明：</p>
<p>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。<br>我们可以不考虑输出结果的顺序。</p>
</blockquote>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>遍历较短的数组, 使用哈希表来存储每一个元素出现的次数.</p>
<p>然后遍历另外一个数组, 查看元素是否在哈希表中. 如果在, 则将其 添加到结果数组中, 并且更新哈希表中的值.</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] tmp = nums1;</span><br><span class="line">            nums1 = nums2;</span><br><span class="line">            nums2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = hashMap.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            hashMap.put(num, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = hashMap.getOrDefault(num, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res[len++] = num;</span><br><span class="line">                cnt--;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    hashMap.put(num, cnt);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    hashMap.remove(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(res, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200713101027073.png" alt="image-20200713101027073"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-32-最长有效括号</title>
    <url>/2020/07/04/Leetcode-32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>
<p>示例 1:</p>
<p>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”<br>示例 2:</p>
<p>输入: “)()())”<br>输出: 4<br>解释: 最长有效括号子串为 “()()”</p>
</blockquote>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>对于括号匹配问题, 最经典的处理方法是使用栈.</p>
<p>遍历字符串:</p>
<ul>
<li>遇到<code>(</code>时, 将其下标入栈</li>
<li>遇到<code>)</code>时, 说明括号匹配正常. 出栈并计算当前下标能够成的有效括号子串.</li>
</ul>
<p>问题就在于如何计算出栈时的最长有效括号字串.</p>
<p>我们可以先将<code>-1</code>置于栈底. </p>
<ul>
<li>如果出栈之后栈底不为空, 则将当前的下标减去栈顶, 就是当前的有效括号子串.</li>
<li>如果出栈之后栈底为空, 那么将当前下标(必为右括号<code>)</code>的下标) 放入栈底即可.</li>
</ul>
<p>过程如图所示</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/NWdLGFHexnODJ6T.png" alt=""></p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/幻灯片2.PNG" alt=""></p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.push(-<span class="number">1</span>); </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res = Math.max(res, i - stack.peek());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/20200704112142.png" alt=""></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-378-有序矩阵中第K小的元素</title>
    <url>/2020/07/02/Leetcode-378-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。<br>请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。</p>
<p>示例：</p>
<p>matrix = [<br>  [ 1,  5,  9],<br>  [10, 11, 13],<br>  [12, 13, 15]<br>],<br>k = 8,</p>
<p>返回 13。</p>
<p>提示：<br>你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。</p>
</blockquote>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>由题目给出的性质可知, 矩阵内的元素左上角最小, 右下角最大. 假设<code>left</code>和<code>right</code>分别为二分法使用时的最大最小值. 使用二分法的步骤是</p>
<ol>
<li><p>计算出矩阵内最大值和最小值的均值(即<code>mid=(left+right)/2</code>)</p>
</li>
<li><p>然后从矩阵的左下角(<code>matrix[n-1][0]</code>)到右上角(<code>matrix[0][n-1]</code>)进行遍历, 找出小于等于<code>mid</code>的元素的个数.</p>
<p> 如图所示, 如果当前元素<code>matrix[i][j]</code>小于等于<code>mid</code>, 则小于等于<code>mid</code>的元素共有<code>i+1</code>个(考虑到数组下标从0开始), 并且向右移动. 否则向上移动. 直至最后走出矩阵.</p>
</li>
<li><p>计算出来小于等于<code>mid</code>的元素数目大于k, 说明二分算法需要在右边继续. 否则二分算法在左边继续.</p>
</li>
</ol>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/GnkxwahZm8bVX3i.png" alt=""></p>
<p>代码如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> left = matrix[<span class="number">0</span>][<span class="number">0</span>], right = matrix[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (lessEqualThanMid(matrix, mid) &lt; k) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lessEqualThanMid</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">1</span>, j = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &lt;= mid) &#123;</span><br><span class="line">                sum += i + <span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/fwItNrWZ6vXkjuK.png" alt=""></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-44-通配符匹配</title>
    <url>/2020/07/05/Leetcode-44-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>
<p>‘?’ 可以匹配任何单个字符。<br>‘*’ 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p>
<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。<br>示例 1:</p>
<p>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。<br>示例 2:</p>
<p>输入:<br>s = “aa”<br>p = “<em>“<br>输出: true<br>解释: ‘</em>‘ 可以匹配任意字符串。<br>示例 3:</p>
<p>输入:<br>s = “cb”<br>p = “?a”<br>输出: false<br>解释: ‘?’ 可以匹配 ‘c’, 但第二个 ‘a’ 无法匹配 ‘b’。<br>示例 4:</p>
<p>输入:<br>s = “adceb”<br>p = “<em>a</em>b”<br>输出: true<br>解释: 第一个 ‘<em>‘ 可以匹配空字符串, 第二个 ‘</em>‘ 可以匹配字符串 “dce”.<br>示例 5:</p>
<p>输入:<br>s = “acdcb”<br>p = “a*c?b”<br>输出: false</p>
</blockquote>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>可以用动态规划的思想来解决此题.</p>
<p>假设<code>dp[i][j]</code>表示字符串<code>s</code>的前<code>i</code>个字符和模式<code>p</code>的前<code>j</code>个字符能否匹配.</p>
<p>那么就有:</p>
<ol>
<li><p>若<code>p[j]</code>是<code>*</code>, 说明模式<code>p</code>对字符串没有任何要求, 若<code>*</code>匹配的是空字符串, 则说明当前<code>dp[i][j]</code>依赖于<code>dp[i][j-1]</code>. 如果<code>*</code>匹配的不是空字符串, 那么<code>dp[i][j]</code>则依赖于<code>dp[i-1][j]</code>. 即转移方程为:</p>
<script type="math/tex; mode=display">
dp[i][j]=dp[i][j-1]\ ||\ dp[i-1][j]</script></li>
<li><p>若<code>p[j]</code>是<code>?</code>, 说明模式<code>p</code>可以匹配任何一个字符, 当前字符匹配的结果取决于前一个字符匹配的结果. 动态转移方程为:</p>
<script type="math/tex; mode=display">
dp[i][j]=dp[i-1][j-1]</script></li>
<li><p>若<code>p[j]</code>是小写字母(最后剩下的情况), 那么<code>s[i]</code>和<code>p[j]</code>必须是相同的字母, 动态转移方程为:</p>
<script type="math/tex; mode=display">
dp[i][j]=(s[i]==s[j])\ and\ dp[i-1][j-1]</script></li>
</ol>
<p>接下来看一下<code>dp</code>数组的边界情况.</p>
<ol>
<li>当<code>i=j=0</code>时, 用空模式去匹配空字符串, 结果必然为真, 即<code>dp[0][0]=true</code></li>
<li>当<code>j=0</code>, <code>i!=0</code>时, 用空模式去匹配非空字符串, 结果必然为假, 即<code>dp[i][0]=false</code></li>
<li>当<code>i=0</code>, <code>j!=0</code>时, 用模式去匹配空字符串, 此时只有模式在<code>j</code>之前都为<code>*</code>才为真.</li>
</ol>
<p>具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化dp</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp迭代</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'?'</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>)) &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/4JAkoUdcKaSI6tx.png" alt=""></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-617 合并二叉树</title>
    <url>/2020/05/06/Leetcode-617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/3PNfBuki8K2Zmwd.png" alt=""><br>注意: 合并必须从两个树的根节点开始</p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>直接使用前序遍历同时遍历两棵树, 将二者的结点相加起来(以t1树为基)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t1.val += t2.val;</span><br><span class="line">t1.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">t1.right = mergeTrees(t1.right, t2.right);</span><br></pre></td></tr></table></figure>
<p>这是递归体, 然后解决递归基的问题. 这个也很简单, 当t1为空时返回t2, t2为空时返回t1即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (t1 == <span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line"><span class="keyword">if</span> (t2 == <span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br></pre></td></tr></table></figure>
<p>汇总一下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        t1.val += t2.val;</span><br><span class="line">        t1.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        t1.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/yI43gPH6ci89pUY.png" alt=""></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>前序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-590 N叉树的后序遍历</title>
    <url>/2020/05/07/Leetcode-590-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给定一个 N 叉树，返回其节点值的<em>后序遍历</em>。</p>
<p>例如，给定一个 <code>3叉树</code> :</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/3PbGIRixKQN8CkU.png" alt=""></p>
<p>返回其后序遍历: <code>[5,6,3,2,4,1]</code>.</p>
<p><strong>说明:</strong> 递归法很简单，你可以使用迭代法完成此题吗?</p>
</blockquote>
<h1 id="思路一-递归法"><a href="#思路一-递归法" class="headerlink" title="思路一: 递归法"></a>思路一: 递归法</h1><p>正如题目中所言, 递归法确实很简单, 利用二叉树中的”左-右-根”顺序进行推广, 即先遍历子树, 最后将根的值放入<code>list</code>中即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        postorder(root, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(Node root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">            postorder(child, list);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/p7SHxJPRVlu6Toj.png" alt=""></p>
<h1 id="思路二-迭代"><a href="#思路二-迭代" class="headerlink" title="思路二: 迭代"></a>思路二: 迭代</h1><p>树的遍历除了用递归实现, 还可以用迭代实现.</p>
<ol>
<li>先将根结点入栈</li>
<li>取出栈中结点, 并将结点的值放入结果队列的头部, 将其子结点按左到右的顺序入栈</li>
<li>重复第二步直至栈为空</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Node&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> output;</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Node tmpNode = stack.pollLast();</span><br><span class="line">            output.addFirst(tmpNode.val);</span><br><span class="line">            <span class="keyword">for</span> (Node child : tmpNode.children) &#123;</span><br><span class="line">                stack.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/05/09/Gqe5HuVD7gX2KOS.png" alt=""></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>后序遍历</tag>
        <tag>迭代遍历树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-63-不同路径Ⅱ</title>
    <url>/2020/07/06/Leetcode-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/robot_maze.png" alt="img"></p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p>示例 1:</p>
<p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li>
</ol>
</blockquote>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>本题就是经典的动态规划题目. </p>
<p>使用<code>dp[i][j]</code>来表示到达<code>obstacleGrid[i][j]</code>时的路径数. 明显<code>dp[i][j]</code>的路径数目等于左边<code>dp[i][j-1]</code>的路径数目加上上面<code>dp[i-1][j]</code>的路径数目. 即动态转移方程为</p>
<script type="math/tex; mode=display">
dp[i][j]=dp[i][j-1]+dp[i-1][j]</script><p>初始化时, 需要将<code>dp[0][0]</code>设置为1.</p>
<p>在遍历的过程中如果遇到<code>obstacleGrid[i][j]==1</code>, 说明遇到了障碍, 对应的<code>dp[i][j]</code>需要置为0, 表示此处已经没有路径了.</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] += dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m -<span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200706090435697.png" alt="image-20200706090435697"></p>
<p>需要注意的地方是, Leetcode的测试用例中, 包含了在入口和出口设置障碍的情况. 但是上述代码中, 当<code>obstacleGrid[i][j]==1</code>时, 将<code>dp[i][j]</code>设置为0, 则可以避开这个问题.</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-718 最长重复子数组</title>
    <url>/2020/07/01/Leetcode-718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p>
<p>示例 1:</p>
<p>输入:<br>A: [1,2,3,2,1]<br>B: [3,2,1,4,7]</p>
<p>输出: 3</p>
<p>解释:<br>长度最长的公共子数组是 [3, 2, 1]。</p>
<p>说明:</p>
<p>1 &lt;= len(A), len(B) &lt;= 1000<br>0 &lt;= A[i], B[i] &lt; 100</p>
</blockquote>
<h1 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h1><p>首先看一下暴力解法. </p>
<p>使用下标<code>i</code>遍历数组<code>A</code>, 使用下标<code>j</code>遍历数组<code>B</code>. 寻找以元素<code>A[i]</code>和<code>B[j]</code>为首的最长公共数组长度$s_{ij}$, 那么全局的最长公共数组长度为</p>
<script type="math/tex; mode=display">
s=\max_{i=1..A.length, j=1..B.length}\{s_{ij}\}</script><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i + k &lt; A.length &amp;&amp; j + k &lt; B.length </span><br><span class="line">                       &amp;&amp; A[i + k] == B[j + k]) &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                    s = Math.max(s, k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为$O(n^3)$</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>在暴力解法当中, 元素<code>A[i]</code>和元素<code>B[j]</code>会进行多次比较. 可以利用动态规划来进行优化, 使得元素<code>A[i]</code>和元素<code>B[j]</code>只会进行一次比较. </p>
<p>令<code>dp[i][j]</code>为元素<code>A[i]</code>和元素<code>B[j]</code>的最长公共重复子数组长度. 那么我们可以知道, 若<code>A[i]==B[j]</code>, 则有<code>dp[i][j]=dp[i+1][j+1]+1</code>; 若<code>A[i]!=B[j]</code>, 则有<code>dp[i][j]=0</code>. 由于<code>dp[i][j]</code>依赖于<code>dp[i+1][j+1]</code>, 所以<code>i</code>和<code>j</code>需要从后往前遍历.</p>
<p>代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findLength(int[] A, int[] B) &#123;</span><br><span class="line">        int m &#x3D; A.length, n &#x3D; B.length;</span><br><span class="line">        int[][] dp &#x3D; new int[m + 1][n + 1];  &#x2F;&#x2F; default 0</span><br><span class="line">        int s &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; m - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            for (int j &#x3D; n - 1; j &gt;&#x3D; 0; j--) &#123;</span><br><span class="line">                if (A[i] &#x3D;&#x3D; B[j]) &#123;</span><br><span class="line">                    dp[i][j] &#x3D; dp[i + 1][j + 1] + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                s &#x3D; Math.max(s, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/20200704112142.png" alt=""></p>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/xocLEOu3ebqY9kD.jpg" alt=""></p>
<p>如图所示, 分别枚举数组<code>A</code>向右移动和数组<code>B</code>向右移动的所有情况, 然后计算红框内最大的公共数组长度.</p>
<p>代码如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length, n = B.length;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A move</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = Math.min(n - i, m); <span class="comment">// 取重叠处的长度</span></span><br><span class="line">            <span class="keyword">int</span> tmp = maxLength(A, B, <span class="number">0</span>, i, len);  <span class="comment">// 计算红框处的最大公共子数组长度</span></span><br><span class="line">            s = Math.max(s, tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// B move</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = Math.min(m - i, n);</span><br><span class="line">            <span class="keyword">int</span> tmp = maxLength(A, B, i, <span class="number">0</span>, len);</span><br><span class="line">            s = Math.max(s, tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span> startA, <span class="keyword">int</span> startB, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[startA + i] == B[startB + i]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s = Math.max(s, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/KwB1Ss6XOgYTj4G.png" alt=""></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-700 二叉搜索树中的搜索</title>
    <url>/2020/05/07/Leetcode-700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84x%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<p>例如，</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/svUFkgS7XHDE9Ct.png" alt=""></p>
<p>你应该返回如下子树:</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/6BA4Ygj2hZstGqL.png" alt=""></p>
<p>在上述示例中，如果要找的值是 <code>5</code>，但因为没有节点值为 <code>5</code>，我们应该返回 <code>NULL</code></p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>思路非常简单, 利用搜索二叉树左小右大的性质进行递归即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.val == val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; val) <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/NXn2SJEmo1epWHq.png" alt=""></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-96-不同的二叉搜索树</title>
    <url>/2020/07/15/Leetcode-96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200715161855733.png" alt="image-20200715161855733"></p>
</blockquote>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>对于有序序列<code>1...n</code>, 假设以数字<code>j</code>为根, 那么构造搜索二叉树的时候, 序列<code>1...(j-1)</code>为左子树的元素, 序列<code>(j+1)..n</code>则为右子树的元素.</p>
<p>假设<code>dp[j]</code>为长度为<code>j</code>的序列所能组成的二叉搜索树数目.</p>
<p>那么由图可知, 假设<code>i</code>为序列的总长度, 则有<code>dp[j]=dp[j-1]*dp[i-j]</code></p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200715163040993.png" alt="image-20200715163040993"></p>
<p>对于长度为<code>i</code>的序列, 进行<code>j=1..i</code>的遍历, 累计构造出来的子树的数量即可. 代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200715163222316.png" alt="image-20200715163222316"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-785-判断二分图</title>
    <url>/2020/07/16/Leetcode-785-%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给定一个无向图graph，当这个图为二分图时返回true。</p>
<p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p>
<p>graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200716102844735.png" alt="image-20200716102844735"></p>
<p>注意:</p>
<p>graph 的长度范围为 [1, 100]。<br>graph[i] 中的元素的范围为 [0, graph.length - 1]。<br>graph[i] 不会包含 i 或者有重复的值。<br>图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。</p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>对图中的节点进行染色. 以任意一个节点开始, 将其染成红色, 然后对图进行遍历, 将其邻居染成黑色. 然后将黑色的邻居染成红色. 如果可以染色成功, 说明这个图是二分图, 两个集合分别是黑色节点和红色节点. 如果染色不能成功, 说明该图不是二分图.</p>
<p>遍历图的思路主要有两种, 分别是深度优先搜索DFS和广度优先搜索BFS. </p>
<h1 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 染色的标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> UNCOLOR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> BLACK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记节点是否染色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] colorFlag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否符合题目要求</span></span><br><span class="line">    <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        colorFlag = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 因为图不一定是连通的, 所以需要以所有为染色的节点为起点去染色</span></span><br><span class="line">            <span class="keyword">if</span> (colorFlag[i] == UNCOLOR) &#123;</span><br><span class="line">                dfs(i, RED, graph);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> color, <span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对当前节点进行染色</span></span><br><span class="line">        colorFlag[node] = color;</span><br><span class="line">        <span class="comment">// 确定相邻节点需要染的颜色</span></span><br><span class="line">        <span class="keyword">int</span> colorOfNeighbour = color == RED? BLACK: RED;</span><br><span class="line">        <span class="comment">// 遍历相邻的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbour: graph[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (colorFlag[neighbour] == UNCOLOR) &#123;</span><br><span class="line">                dfs(neighbour, colorOfNeighbour, graph);</span><br><span class="line">                <span class="comment">// 通过上面的dfs, 如果不是二分图, 则直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colorFlag[neighbour] != colorOfNeighbour) &#123;</span><br><span class="line">                <span class="comment">// 如果相邻节点已经有颜色, 而且和确定要染的颜色不一样的话, 则说明不是二分图</span></span><br><span class="line">                <span class="comment">// 不满足题目要求</span></span><br><span class="line">                valid = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200716103505511.png" alt="image-20200716103505511"></p>
<h1 id="广度优先搜索BFS"><a href="#广度优先搜索BFS" class="headerlink" title="广度优先搜索BFS"></a>广度优先搜索BFS</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 染色的标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> UNCOLOR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> BLACK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记节点是否染色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] colorFlag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        colorFlag = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 因为图不一定是连通的, 所以需要以所有为染色的节点为起点去染色</span></span><br><span class="line">            <span class="keyword">if</span> (colorFlag[i] == UNCOLOR) &#123;</span><br><span class="line">                Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                <span class="comment">// 先将第一个节点入队</span></span><br><span class="line">                queue.offer(i);</span><br><span class="line">                colorFlag[i] = RED;</span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 队首节点出队</span></span><br><span class="line">                    <span class="keyword">int</span> node = queue.poll();</span><br><span class="line">                    <span class="comment">// 确认出队节点的相邻节点需要染的颜色</span></span><br><span class="line">                    <span class="keyword">int</span> colorOfNeighbour = colorFlag[node] == RED? BLACK: RED;</span><br><span class="line">                    <span class="comment">// 遍历出队节点的所有相邻节点</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> neighbour: graph[node]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (colorFlag[neighbour] == UNCOLOR) &#123;</span><br><span class="line">                            <span class="comment">// 如果当前相邻节点还没有染色</span></span><br><span class="line">                            <span class="comment">// 入队</span></span><br><span class="line">                            queue.offer(neighbour);</span><br><span class="line">                            <span class="comment">// 染色</span></span><br><span class="line">                            colorFlag[neighbour] = colorOfNeighbour;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colorFlag[neighbour] != colorOfNeighbour) &#123;</span><br><span class="line">                            <span class="comment">// 如果当前相邻节点已染色, 且与需要染的颜色不一样</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200716105628992.png" alt="image-20200716105628992"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-938 二叉搜索树的范围和</title>
    <url>/2020/05/06/Leetocde-938-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。</p>
<p>二叉搜索树保证具有唯一的值。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>root = [10,5,15,3,7,null,18], L = 7, R = 15<br><strong>输出：</strong>32</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10<br><strong>输出：</strong>23</p>
<p><strong>提示：</strong></p>
<ol>
<li>树中的结点数量最多为 10000 个。</li>
<li>最终的答案保证小于 2^31。</li>
</ol>
</blockquote>
<h1 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h1><p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/W8KDpkYQM1ATrXH.png" alt=""></p>
<p>直接遍历整个二叉树, 寻找大于等于L和小于等于R的结点的总和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cntBSt(root, L, R);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cntBSt</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; L || root.val &gt; R) result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> result = root.val;</span><br><span class="line">        result += cntBSt(root.left, L, R);</span><br><span class="line">        result += cntBSt(root.right, L, R);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/sw9UMih4AOCaPDS.png" alt=""></p>
<h1 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h1><p>对上面的方法进行优化, 因为给定的树是二叉搜索树, 所以</p>
<ul>
<li>当结点小于L时, 只搜索该结点的右子树(左子树均小于L)</li>
<li>当结点大于R时, 只搜索该结点的左子树(右子树均大于R)</li>
</ul>
<p>换句话说</p>
<ul>
<li>只有结点大于L时, 才搜索左子树</li>
<li>只有结点小于R时, 才搜索右子树</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cntBSt(root, L, R);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cntBSt</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; L || root.val &gt; R) result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> result = root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; L) result += cntBSt(root.left, L, R);  <span class="comment">// val大于L才能进行搜索左子树</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; R) result += cntBSt(root.right, L, R); <span class="comment">// val小于R才能进行搜索右子树</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/JnMYbjp34PxI7Ev.png" alt=""></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo+Github Page从零开始搭建自己的博客(一)——环境配置</title>
    <url>/2020/01/08/%E5%88%A9%E7%94%A8Hexo+Github%20Page%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%B8%80)%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Hexo的介绍和安装"><a href="#Hexo的介绍和安装" class="headerlink" title="Hexo的介绍和安装"></a>Hexo的介绍和安装</h1><h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo?"></a>什么是Hexo?</h2><p><code>Hexo</code>是一个非常流行, 易于上手的博客框架. 利用这个博客框架, 我们可以免去自己写代码构建网站的麻烦, 只需要安装好博客框架, 选择自己喜欢的主题, 就可以搭建自己的个性化网站了！</p>
<h2 id="Hexo的环境配置"><a href="#Hexo的环境配置" class="headerlink" title="Hexo的环境配置"></a>Hexo的环境配置</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p><code>Hexo</code>是基于<code>Node.js</code>开发的博客框架, 所以我们首先需要安装<code>Node.js</code>.<br>直接从<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js官网</a>下载安装即可.</p>
<p>注意<code>Node.js</code>版本不应该低于8.10, 推荐使用<code>Node.js</code> 10.0以上版本.</p>
<p>安装时选择默认安装全部即可, 如图所示.</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/OkVQonefb8ISqiA.jpg" alt="node.js安装"></p>
<p>安装完成后可以在终端里面输入(Windows下可以使用<code>cmd</code>或者<code>powershell</code>里面输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>来查看是否安装成功.</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/LXHPl9SIKk7dnGR.png" alt="查看node.js版本信息"></p>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p><code>git</code>是一个常用的分布式版本控制系统. 若想要详细了解<code>git</code>, 可以参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰的Git教程</a></p>
<p>点击<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">这里</a>安装<code>git</code>.</p>
<p>安装完成后, 在<code>cmd</code>输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git version</span><br></pre></td></tr></table></figure>
<p>查看git版本信息</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/gRFZzbY27O8aWLI.png" alt="查看git版本信息"></p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>上述环境搭好之后, 就可以利用<code>npm</code>进行<code>Hexo</code>的安装了.</p>
<p>只要在命令行下执行下面命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>安装完成之后, 在终端执行以下命令来初始化自己的博客目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init myBlog</span><br></pre></td></tr></table></figure>
<p>上面这条命令是在当前目录内新建一个<code>myBlog</code>文件夹, 并在<code>myBlog</code>文件夹里初始化了一些创建博客所需要的文件.</p>
<p>比如说你是在<code>C:\Users\yourUserName\&gt;</code>下执行了上述命令, 则会在对应的目录下新建一个<code>myBlog</code>文件夹.</p>
<p>然后可以利用<code>cd</code>命令进行<code>myBlog</code>文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd myBLog</span><br></pre></td></tr></table></figure>
<p>然后执行以下命令, 利用<code>npm</code>进行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>完成安装后, <code>myBlog</code>文件夹的下的目录如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 </span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds # 模版文件夹</span><br><span class="line">├── source  # 资源文件夹</span><br><span class="line">|   ├── _drafts # 草稿文件</span><br><span class="line">|   └── _posts # 文章Markdowm文件 </span><br><span class="line">└── themes  # 主题文件夹</span><br></pre></td></tr></table></figure>
<p>安装完成之后, 在<code>myBlog</code>目录下运行<code>hexo s</code>命令, 然后在浏览器中输入 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 就可以预览网页了.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<h1 id="将博客部署到GitHub"><a href="#将博客部署到GitHub" class="headerlink" title="将博客部署到GitHub"></a>将博客部署到GitHub</h1><h2 id="注册GitHub"><a href="#注册GitHub" class="headerlink" title="注册GitHub"></a>注册GitHub</h2><p>如果你还没有GitHub的账号, 可以在<a href="https://www.github.com" target="_blank" rel="noopener">GitHub官网</a>进行注册.</p>
<p>顺便提一下:</p>
<p>是Git和GitHub是两个不同概念的东西:</p>
<ol>
<li>Git一个是版本控制系统</li>
<li>GitHub是一个用Git版本控制的代码托管平台</li>
</ol>
<h2 id="创建GitHub-Page"><a href="#创建GitHub-Page" class="headerlink" title="创建GitHub Page"></a>创建GitHub Page</h2><p>上面说了, GitHub是一个代码托管平台, 但其实它还提供了一个叫做GitHub Page的功能. 我们可以用GitHub Page作为自己的博客网站.</p>
<p>首先, 需要在GitHub新建一个repository(仓库)</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/MhkgVYLBFPrazIy.png" alt=""></p>
<p>然后点击new</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/2RZzs1KGonaNpOX.png" alt=""></p>
<p>新建的仓库名的格式必须为<code>你的github用户名.github.io</code></p>
<p>需要注意的是github仅能使用一个同名仓库的代码托管一个静态网站</p>
<p>仓库类型选择<code>Public</code></p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/GjhgIdzJUVS26Cr.png" alt=""></p>
<p>打开刚刚创建的仓库, 点击<code>Create new file</code>, 新建一个<code>index.html</code>文件, 在里面随便输入点什么作为测试.</p>
<p>然后选择commit new file, 并在文本框上输入这次commit的备注, 比如”first commit”之类的.</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/NVeaikKSUOvL3IZ.png" alt=""></p>
<p>commit成功之后, 在浏览器中输入 <a href="http://你的用户名.github.io" target="_blank" rel="noopener">http://你的用户名.github.io</a> 就可以看到自己的博客啦(当然, 还没有把hexo中的博客内容添加到github page里面).</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/rhDZ4SkEJAqyQMz.png" alt=""></p>
<h2 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h2><p>为了部署本地博客到github上, 首先需要对git进行本地账户配置.</p>
<p>在终端上执行以下命令, “Your name”和”Your email”填入自己的用户名和邮箱</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name "Your name"</span><br><span class="line">git config --global user.email "Your email"</span><br></pre></td></tr></table></figure>
<p>执行下面命令创建ssh key, 一直按回车保持默认设置即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "Your email"</span><br></pre></td></tr></table></figure>
<p>如果一切顺利的话, 可以在用户主目录处找到<code>.ssh</code>目录, 里面可以看到有<code>id_rsa</code>和’<code>id_rsa.pub</code>两个文件. 其中<code>id_rsa</code>是密钥, 不可以泄露. <code>id_rsa.pub</code>是公钥.</p>
<p>然后登录github, 添加SSH Key</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/6o9FhmzYWkPGnDt.png" alt=""></p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/jNeIf96a5xAprZt.png" alt=""></p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/JLk6NTMmhxKscVG.png" alt=""></p>
<h2 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h2><p>本地和github上的准备工作都做得差不多了, 现在是时候把二者连接起来了.</p>
<ol>
<li><p>打开<code>myBlog</code>项目根目录下的<code>_config.yml</code>配置文件, 拉到文件末尾, 填上如下配置</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/ievKbaDkGUg6zWJ.png" alt=""></p>
</li>
<li><p>安装部署插件</p>
<p>在<code>myBlog</code>目录下执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>安装完成之后, 可以在博客项目根目录下, 即<code>myBlog</code>路径下执行以下命令进行部署上传. 其中<code>g</code>是代表<code>generate</code>,<code>d</code>代表<code>deploy</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>上传成功之后, 稍等片刻, 在浏览器输入 <a href="http://你的用户名.github.io" target="_blank" rel="noopener">http://你的用户名.github.io</a> 就可以看到你自己的博客啦!</p>
</li>
</ol>
<p>   如果发现部署之后, git page还是没有变化, 可以尝试输入</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>   上述这条命令用于清除缓存, 如果你发现部署之后网页没有变化, 可以尝试使用上述命令清楚缓存, 尤其是在更改主题的时候.</p>
<p>   注:</p>
<p>   如果觉得github上传速度慢的话, 可以参考我写的<a href="http://llx42.com/2020/01/12/改善Github连接速度慢的方法/">这篇文章</a></p>
]]></content>
      <categories>
        <category>从零开始创建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo+Github Page从零开始搭建自己的博客(二)——开始写作</title>
    <url>/2020/01/12/%E5%88%A9%E7%94%A8Hexo-Github-Page%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C-%E2%80%94%E2%80%94%E5%BC%80%E5%A7%8B%E5%86%99%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="创建你的第一篇文章"><a href="#创建你的第一篇文章" class="headerlink" title="创建你的第一篇文章"></a>创建你的第一篇文章</h1><h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><p>使用Hexo框架新建文章非常简单, 只需要在<code>myBlog</code>目录下执行以下命令即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new post '第一篇文章'</span><br></pre></td></tr></table></figure>
<p>执行完成之后, 就可以在<code>myBlog\source\_posts</code>目录下找到<code>&quot;第一篇文章.md&quot;</code>文件.</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/Aw31Vn5bjOFQIJg.png" alt=""></p>
<p><code>md</code>是<code>markdown</code>的缩写, 下一节会介绍什么是<code>markdown</code>.</p>
<p>markdown编辑器有很多, 我自己使用的是<code>typora</code>, <a href="https://www.typora.io/" target="_blank" rel="noopener">这里</a>是<code>typora</code>的官网.</p>
<h2 id="Hexo中的布局"><a href="#Hexo中的布局" class="headerlink" title="Hexo中的布局"></a>Hexo中的布局</h2><p>刚刚提到的<code>post</code>是Hexo中布局(Layout)的一种. Hexo默认的布局有三种:<code>post</code>, <code>page</code>和<code>draft</code>, 分别代表了文章, 页面和草稿, 它们会被保存到不同的路径.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">布局</th>
<th style="text-align:center">路径</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">post</td>
<td style="text-align:center">source\\_posts</td>
</tr>
<tr>
<td style="text-align:center">page</td>
<td style="text-align:center">source</td>
</tr>
<tr>
<td style="text-align:center">draft</td>
<td style="text-align:center">source\\_drafts</td>
</tr>
</tbody>
</table>
</div>
<p>比较常用的有文章post和草稿draft. 新建post的方法在上面也提到过了, 即</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new post '文章名'</span><br></pre></td></tr></table></figure>
<p>新建草稿则是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new draft '文章名'</span><br></pre></td></tr></table></figure>
<p>如果想将草稿移动到<code>source/_posts</code>文件夹, 则可以使用<code>publish</code>命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo publish post '文章名'</span><br></pre></td></tr></table></figure>
<p>写好文章(post)之后, 需要在终端中进行生成(<code>hexo g</code>)和部署(). 不过在生成和部署之前, 最好使用<code>clean</code>命令清除缓存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<h2 id="分类与标签"><a href="#分类与标签" class="headerlink" title="分类与标签"></a>分类与标签</h2><p>新建的hexo文章会有一个头文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: xxx</span><br><span class="line">date: yyyy-dd-mm</span><br></pre></td></tr></table></figure>
<p>可以在下面添加categories字段来说明分类, tags字段说明标签</p>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: xxx</span><br><span class="line">date: yyyy-dd-mm</span><br><span class="line">categories:</span><br><span class="line">- 分类</span><br><span class="line">tags:</span><br><span class="line">- 标签1</span><br><span class="line">- 标签2</span><br></pre></td></tr></table></figure>
<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><p>Hexo中默认生成的新文章是Markdown格式的. Markdown是一种轻量级的标记语言, 相对于HTML, Latex等复杂的语法而言, Markdown的语法规则更为简单.</p>
<p>下面做一些简单的介绍, 详细的可以看John Gguber的<a href="https://daringfireball.net/projects/markdown/syntax" target="_blank" rel="noopener">博客</a>以及其<a href="https://markdown-zh.readthedocs.io/en/latest/" target="_blank" rel="noopener">中译版</a>.</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>在Markdown中, 只要在文本前面加上<code>#</code>号, 并用空格隔开, 总共有六级标题. 例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
<p>在Typora中, 输入Markdown语法之后会立刻渲染, 显示如下.</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200705180524567.png" alt="image-20200705180524567"></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>无序列表使用<code>-</code>或者<code>*</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 项目1</span><br><span class="line">- 项目2</span><br><span class="line">- 项目3</span><br></pre></td></tr></table></figure>
<ul>
<li>项目1</li>
<li>项目2</li>
<li>项目3</li>
</ul>
<p>有序列表使用数字+<code>.</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 项目1</span><br><span class="line">2. 项目2</span><br><span class="line">3. 项目3</span><br></pre></td></tr></table></figure>
<ol>
<li>项目1</li>
<li>项目2</li>
<li>项目3</li>
</ol>
<h2 id="插入超链接"><a href="#插入超链接" class="headerlink" title="插入超链接"></a>插入超链接</h2><p>插入超链接的方式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[链接名称](超链接)</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[百度](http:&#x2F;&#x2F;www.baidu.com)</span><br></pre></td></tr></table></figure>
<p>效果为: <a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a></p>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>插入图片的方式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片名称](图片路径)</span><br></pre></td></tr></table></figure>
<p>其中图片路径可以是本地的相对路径或者绝对路径, 也可以是网络上的路径. 一般在部署博客时, 会使用图床来存放图片, 然后在博客上使用网络路径引用图片. 这样做的好处是部署博客时不需要上传图片, 加快部署速度. </p>
<p>具体的图床配置下一小节会提到.</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 引用内容</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用内容</p>
</blockquote>
<p>可以嵌套使用引用</p>
<blockquote>
<p>引用内容</p>
<blockquote>
<p>引用引用内容</p>
<blockquote>
<p>引用引用引用内容</p>
<blockquote>
<p>禁止套娃</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**粗体**</span><br><span class="line">*斜体*</span><br></pre></td></tr></table></figure>
<p><strong>粗体</strong></p>
<p><em>斜体</em></p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 项目1 | 项目2 | 项目3 |</span><br><span class="line">| ----- | ----- | ----- |</span><br><span class="line">| 内容1 | 内容2 | 内容3 |</span><br><span class="line">| 内容4 | 内容5 | 内容6 |</span><br><span class="line">| 内容7 | 内容8 | 内容9 |</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>项目1</th>
<th>项目2</th>
<th>项目3</th>
</tr>
</thead>
<tbody>
<tr>
<td>内容1</td>
<td>内容2</td>
<td>内容3</td>
</tr>
<tr>
<td>内容4</td>
<td>内容5</td>
<td>内容6</td>
</tr>
<tr>
<td>内容7</td>
<td>内容8</td>
<td>内容9</td>
</tr>
</tbody>
</table>
</div>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h3 id="行内代码块"><a href="#行内代码块" class="headerlink" title="行内代码块"></a>行内代码块</h3><p>行内代码块使用两个` 将代码包裹起来, 比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对变量&#96;i&#96;进行自增</span><br></pre></td></tr></table></figure>
<p>效果如下:</p>
<p>对变量<code>i</code>进行自增</p>
<h3 id="行间代码块"><a href="#行间代码块" class="headerlink" title="行间代码块"></a>行间代码块</h3><p>行间代码块使用一对```来将代码包裹起来. 在第一个```后面可以标记上所使用的语言, 比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&#96;&#96;&#96;Java</span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">	System.out.println(&quot;Hello, fucking world!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;Java</span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">    System.out.println(&quot;Hello, fucking world!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>连续输入三个*号就是分割线</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">分割线</span><br><span class="line">***</span><br><span class="line">分割线</span><br><span class="line">***</span><br></pre></td></tr></table></figure>
<hr>
<p>分割线</p>
<hr>
<p>分割线</p>
<hr>
<h1 id="图床配置"><a href="#图床配置" class="headerlink" title="图床配置"></a>图床配置</h1><p>图床是指存储图片的服务器, 使用图床的好处是可以减轻博客服务器的负担, 加快图片打开的速度. </p>
<h2 id="免费图床"><a href="#免费图床" class="headerlink" title="免费图床"></a>免费图床</h2><p>可以使用<a href="https://imgchr.com/" target="_blank" rel="noopener">路过图床</a>等免费图床上传图片. 在网站注册完成之后, 就可以上传图片了. 上传完成之后, 直接将Markdown的链接放到自己的Markdown文件就可以了.</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200706152534392.png" alt="image-20200706152534392"></p>
<h2 id="Typora图片自动上传"><a href="#Typora图片自动上传" class="headerlink" title="Typora图片自动上传"></a>Typora图片自动上传</h2><p>一旦文章里面用到的图片很多时, 一张张上传到图床并手动复制到Markdown文件里面是一件很麻烦的事情. 在Windows平台上可以通过Typora搭配PicGo来实现自动上传. 也是就说, 只要把图片复制到Typora上, 就可以实现自动上传到图床了.</p>
<h3 id="安装Typora和PicGo"><a href="#安装Typora和PicGo" class="headerlink" title="安装Typora和PicGo"></a>安装Typora和PicGo</h3><ul>
<li>Typora需要到<a href="https://www.typora.io" target="_blank" rel="noopener">官网</a>下载安装, 需要<code>0.9.86</code>版本以上</li>
<li>PicGo在对应的PicGo<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">release页面</a>下载安装, 需要<code>2.2.2</code>版本以上</li>
</ul>
<p>PicGo默认支持的图床包括了SM.MS图床等, 如图所示.</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200706155636562.png" alt="image-20200706155636562"></p>
<p>SM.MS图床和GitHub图床使用是免费的, 但是SM.MS图床稳定性较差, Github图床访问需翻墙. </p>
<p>略, 待补充.</p>
<h1 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h1><p>略, 待补充.</p>
<h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><p>Hexo支持更换主题, 可以在官方的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题市场</a>中下载自己喜欢的主题.</p>
<p>下面以NexT主题为例, 介绍如何安装主题. </p>
<h2 id="站点配置文件和主题配置文件"><a href="#站点配置文件和主题配置文件" class="headerlink" title="站点配置文件和主题配置文件"></a>站点配置文件和主题配置文件</h2><p>在配置主题前, 要先了解什么是<code>站点配置文件</code>和<code>主题配置文件</code>.</p>
<p>在<code>myBlog</code>目录下, 也就是站点根目录下的<code>_config.yml</code>文件称作<code>站点配置文件</code>.</p>
<p>在<code>myBlog\themes\主题名\</code>目录下的的<code>_config.yml</code>文件称作<code>主题配置文件</code></p>
<h2 id="下载NexT主题"><a href="#下载NexT主题" class="headerlink" title="下载NexT主题"></a>下载NexT主题</h2><p>首先在<a href="https://codeload.github.com/iissnan/hexo-theme-next/zip/v5.1.2" target="_blank" rel="noopener">此链接</a>中下载Hexo的5.1.2版本.</p>
<p>然后将压缩包解压, 将解压后的文件名(<code>hexo-theme-next-5.1.2</code>)改为<code>next</code>. 并将整个文件夹复制到<code>myBlog\themes</code>目录下面.</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200706170951254.png" alt="image-20200706170951254"></p>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>打开<code>站点配置文件</code>, 找到<code>theme</code>字段, 将值更改为<code>next</code></p>
<p><img src="C:\Users\83452\AppData\Roaming\Typora\typora-user-images\image-20200706171219355.png" alt="image-20200706171219355"></p>
<p>NexT主题有三种Scheme:</p>
<ul>
<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>
<li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li>
<li>Pisces - 双栏 Scheme，小家碧玉似的清新</li>
<li>Gemini - 目前本网站使用的Scheme.</li>
</ul>
<p>如果要切换Scheme的话, 需要打开<code>主题配置文件</code>, 找到<code>Scheme</code>字段, 在<code>scheme:</code>后面输入你喜欢的Scheme名称即可.</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200706173335341.png" alt="image-20200706173335341"></p>
<h2 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h2><p>在<code>站点配置文件</code>中, 将<code>language</code>设置成你所需要的语言, 一般设置为简体中文.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: zh-Hans</span><br></pre></td></tr></table></figure>
<p>如果需要其他更详细的配置, 可以参照<a href="https://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <categories>
        <category>从零开始创建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>改善Github连接速度慢的方法</title>
    <url>/2020/01/12/%E6%94%B9%E5%96%84Github%E8%BF%9E%E6%8E%A5%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="查找适合自己的ip地址"><a href="#查找适合自己的ip地址" class="headerlink" title="查找适合自己的ip地址"></a>查找适合自己的ip地址</h1><p>利用<a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">dns查询工具查询</a>下列域名的ip地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github.com</span><br><span class="line">assets-cdn.github.com</span><br><span class="line">github.global.ssl.fastly.net</span><br><span class="line">assets-cdn.github.com</span><br><span class="line">avatars1.githubusercontent.com</span><br><span class="line">avatars2.githubusercontent.com</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/4ne6cNvDZECLS35.png" alt=""></p>
<p>输入域名, 点击检测, 选择TTL较小的ip地址, 写成下面的格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">52.74.223.119 github.com</span><br><span class="line">1185.199.108.153 assets-cdn.github.com</span><br><span class="line">31.13.80.1 github.global.ssl.fastly.net</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">151.101.228.133 avatars1.githubusercontent.com</span><br><span class="line">151.101.108.133 avatars2.githubusercontent.com</span><br></pre></td></tr></table></figure>
<h1 id="更改HOST文件"><a href="#更改HOST文件" class="headerlink" title="更改HOST文件"></a>更改HOST文件</h1><p>Windows的HOST文件在<code>C:\Windows\System32\drivers\etc</code>目录下.</p>
<p>要注意的是在此目录下无法更改<code>hosts</code>文件</p>
<ol>
<li><p>将<code>hosts</code>复制到别的目录</p>
</li>
<li><p>使用记事本(或者其他文本编辑器)打开, 将上面所写的ip地址和域名粘贴到<code>hosts</code>文件末端, 保存</p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/5lKk7sidXC9zMhx.png" alt=""></p>
</li>
<li><p>将<code>hosts</code>文件粘贴到<code>C:\Windows\System32\drivers\etc</code>目录替换掉原来的hosts文件即可</p>
</li>
</ol>
<h1 id="刷新本地DNS缓存"><a href="#刷新本地DNS缓存" class="headerlink" title="刷新本地DNS缓存"></a>刷新本地DNS缓存</h1><p>Windows下在<code>cmd</code>下执行下列命令即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇文章</title>
    <url>/2020/01/14/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>树的非递归遍历</title>
    <url>/2020/05/09/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>众所周知, 树的遍历主要有四种方法: 前序遍历, 中序遍历, 后序遍历和层序遍历. 其中, 前中后序遍历最简洁的实现方法就是递归实现, 以二叉树为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历递归实现的伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    visit(root);</span><br><span class="line">   	preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历递归实现的伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    visit(root);</span><br><span class="line">    inorder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历递归实现的伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    visit(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而非递归的实现则会使用栈来代替递归, 因为计算机内部也是用栈来实现递归的.</p>
<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><p>为了方便理解, 先从中序遍历开始讲起.</p>
<p>回忆一下, 二叉树中中序遍历的顺序是: 左子树 - 根 - 右子树, 那么我们一开始肯定要走到树的最左下角, 并将经过的结点进行入栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node p = root;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">    stack.push(p)</span><br><span class="line">    p = p.left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/XFtegyaOTkW3hx2.png" alt=""></p>
<p>从图中可以看见, 当p左边的路径走到尽头之后, 栈顶结点为3, 且有两种情况:</p>
<ol>
<li>没有右儿子</li>
<li>有右儿子</li>
</ol>
<p>对于情况1, 栈顶结点没有右儿子, 直接出栈栈顶结点, 然后访问, p指向右儿子(为空)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">p = stack.pop();</span><br><span class="line">visit(p);</span><br><span class="line">p = p.right; <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>对于情况2, 栈顶结点有右儿子, 直接出栈栈顶结点, 然后访问, p指向右儿子(不为空)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">p = stack.pop();</span><br><span class="line">visit(p);</span><br><span class="line">p = p.right; <span class="comment">// not null</span></span><br></pre></td></tr></table></figure>
<p>上面两个代码将两种情况都统一表示了, 那么如何去区分两种情况呢? 方法很简单, 只要在迭代里面增加对<code>p</code>是否为<code>null</code>进行判断就可以了.</p>
<ul>
<li>如果<code>p</code>为<code>null</code>, 说明栈顶结点没有右子树, 那么我们继续处理栈的下一个结点</li>
<li>如果<code>p</code>不为<code>null</code>, 说明栈顶结点有右子树, 那么我们需要对这个右子树进行一遍上面所说的操作, 也就是说需要走到右子树的”最左边”. 到达”最左边”之后, 继续进行我们所说的这些处理.</li>
</ul>
<p>伪代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (some condition) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;  <span class="comment">// p不为空, 则需要走到"最左边"</span></span><br><span class="line">        stack.push(p);  <span class="comment">// 走的过程中将路过的结点入栈</span></span><br><span class="line">        p = p.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">// p为空, 那么处理栈剩下的结点</span></span><br><span class="line">    	p = stack.pop();  <span class="comment">// 出栈</span></span><br><span class="line">        visit(p);  <span class="comment">// 访问结点</span></span><br><span class="line">        p = p.right;  <span class="comment">// 指向p的右子树, 留到下一个循环去判断p是否为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么代码的大体框架已经写好了, 最后只剩下<code>while()</code>循环里面的条件了, 很明显当栈空且<code>p</code>也为<code>null</code>的情况下需要中止循环, 已经遍历完了. (注意: 当栈为空时, 不一定遍历结束, 因为<code>p</code>不为空的话, 说明还有右子树没有遍历). 转换一下逻辑, 也就是说当栈不空或者<code>p</code>不为<code>null</code>的时候可以继续循环. 完整的伪代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (p != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;  <span class="comment">// p不为空, 则需要走到"最左边"</span></span><br><span class="line">        stack.push(p);  <span class="comment">// 走的过程中将路过的结点入栈</span></span><br><span class="line">        p = p.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">// p为空, 那么处理栈剩下的结点</span></span><br><span class="line">    	p = stack.pop();  <span class="comment">// 出栈</span></span><br><span class="line">        visit(p);  <span class="comment">// 访问结点</span></span><br><span class="line">        p = p.right;  <span class="comment">// 指向p的右子树, 留到下一个循环去判断p是否为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>OK! 伪代码写出来了, 那我们来实践一下吧! Leetcode中的<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94.二叉树的中序遍历</a>这一题就是</p>
<p>考察二叉树中序遍历的迭代实现, 根据上面所说的, 可以很轻松地写下代码(使用Java实现)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = stack.pop();</span><br><span class="line">                result.add(p.val);</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/n2E7hCQZevcJpMi.png" alt=""></p>
<h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><p>前序遍历和中序遍历思想是类似的, 中序遍历需要先入栈再访问, 而先序遍历则是访问再入队. 这样就会满足: 根结点 - 左子树 - 右子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (p != <span class="keyword">null</span> || stack.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p !=  <span class="keyword">null</span>) &#123;  <span class="comment">// p 不为空, 则需要走到"最左边"</span></span><br><span class="line">        visit(p); <span class="comment">// 在入栈之前进行访问结点</span></span><br><span class="line">        stack.push(p);</span><br><span class="line">        p = p.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = stack.pop();  <span class="comment">// 出栈</span></span><br><span class="line">        p = p.right;  <span class="comment">// 指向p的右子树, 留到下一个循环去判断p是否为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK! 同样地, 去Leetcode实践一下-&gt;<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result.add(p.val);</span><br><span class="line">                stack.push(p);</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = stack.pop();</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/5e4vcXzj1wuNlmL.png" alt=""></p>
<h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><p>后序遍历的情况会更复杂一些, 因为后序遍历的顺序是: 左子树 - 右子树 - 根结点. 所以取出栈顶元素之后, 栈顶元素如果:</p>
<ul>
<li>位于左子树中, 需要跳过根结点, 直接访问右子树</li>
<li>位于右子树中, 访问根结点</li>
</ul>
<p>有一种实现方法是在树的结构中增加标记来判断是否需要跳过根结点. 但是我们可以使用更简便地方法, 就是将顺序颠倒一下. </p>
<p>后序遍历的顺序颠倒过来就是: 根结点 - 右子树 - 左子树.</p>
<p>仔细观察一下, 是不是很像前序遍历的顺序? 前序遍历中的顺序是: 根结点 - 左子树 - 右子树.</p>
<p>我们只需要将前序遍历代码中的<code>left</code>和<code>right</code>交换一下, 就可以得到: 根结点 - 右子树 - 左子树的顺序, 最后再将结果反转, 就可以得到”左子树 - 右子树 - 根结点”的顺序. 而实现的时候只需要将结点添加到<code>List</code>的头部就可以了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (p != <span class="keyword">null</span> || stack.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p !=  <span class="keyword">null</span>) &#123;  <span class="comment">// p 不为空, 则需要走到"最右边"</span></span><br><span class="line">        result.addFirst(p); <span class="comment">// 在入栈之前进行访问结点</span></span><br><span class="line">        stack.push(p);</span><br><span class="line">        p = p.right;  <span class="comment">// </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = stack.pop();  <span class="comment">// 出栈</span></span><br><span class="line">        p = p.left;  <span class="comment">// 指向p的左子树, 留到下一个循环去判断p是否为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>
<p>OK! 去Leetcode实践一下-&gt;<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">二叉树的后序遍历</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result.addFirst(p.val);</span><br><span class="line">                stack.push(p);</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = stack.pop();</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/1mKT7ZWgs6P9nLl.png" alt=""></p>
<h1 id="N叉树的遍历"><a href="#N叉树的遍历" class="headerlink" title="N叉树的遍历"></a>N叉树的遍历</h1><p>既然二叉树的遍历已经搞清楚了, 那么我们接下来就推广到N叉树吧. 要注意的是N叉树的中序遍历暂无明确的定义, 所以这里我们只讨论N叉树的前序遍历和后序遍历.</p>
<h2 id="N叉树遍历的递归实现"><a href="#N叉树遍历的递归实现" class="headerlink" title="N叉树遍历的递归实现"></a>N叉树遍历的递归实现</h2><p>先来看看前序遍历和后序遍历的递归伪代码实现吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// N叉树的前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    visit(root)</span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">        preorder(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// N叉树的后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">        postOrder(child);</span><br><span class="line">    &#125;</span><br><span class="line">    visit(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="N叉树前序遍历"><a href="#N叉树前序遍历" class="headerlink" title="N叉树前序遍历"></a>N叉树前序遍历</h2><ol>
<li>先将根结点入栈</li>
<li>队中结点出列, 并将结点的值放入结果队列中, 然后将其子结点从右至左的顺序入队(保证下一个结点是最左边的子结点)</li>
<li>重复第二步直至栈为空</li>
</ol>
<p>直接在Leetocde上面实现看看! <a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/solution/" target="_blank" rel="noopener">N叉树的前序遍历</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Node&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Node tmpNode = stack.pop();</span><br><span class="line">            result.add(tmpNode.val);</span><br><span class="line">            Collections.reverse(tmpNode.children); <span class="comment">// 逆序</span></span><br><span class="line">            <span class="keyword">for</span> (Node child : tmpNode.children) &#123;</span><br><span class="line">                stack.push(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/qL8RM3GuwKZzyel.png" alt=""></p>
<h2 id="N叉树后序遍历"><a href="#N叉树后序遍历" class="headerlink" title="N叉树后序遍历"></a>N叉树后序遍历</h2><ol>
<li>先将根结点入栈</li>
<li>取出栈中结点, 并将结点的值放入结果队列的头部, 将其子结点按左到右的顺序入栈</li>
<li>重复第二步直至栈为空</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Node&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> output;</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Node tmpNode = stack.pollLast();</span><br><span class="line">            output.addFirst(tmpNode.val);</span><br><span class="line">            <span class="keyword">for</span> (Node child : tmpNode.children) &#123;</span><br><span class="line">                stack.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/9iWh4Ka6s3yHFAq.png" alt=""></p>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode-97-交错字符串</title>
    <url>/2020/07/18/Leetcode-97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</p>
<p>示例 1:</p>
<p>输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbcbcac”<br>输出: true<br>示例 2:</p>
<p>输入: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbbaccc”<br>输出: false</p>
</blockquote>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>要判断<code>s3</code>是否由<code>s1</code>和<code>s2</code>交错而成的, 首先看长度.</p>
<p>如果<code>|s1|+|s2| != |s3|</code>, 那么说明<code>s3</code>不是由<code>s1</code>和<code>s2</code>交错而成的.</p>
<p>假设<code>dp[i][j]</code>表示<code>s1</code>的前<code>i</code>个元素和<code>s2</code>的前<code>j</code>个元素<strong>能否</strong>构成<code>s3</code>的前<code>i+j</code>个元素.</p>
<p>那么<code>dp[i][j]</code>取决于<code>dp[i-1][j]</code>, <code>dp[i][j-1]</code>以及对应位置的元素是否相等.</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s1.length(), m = s2.length(), t = s3.length();</span><br><span class="line">        <span class="keyword">if</span> (n + m != t) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> p = i + j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j] || (s1.charAt(i - <span class="number">1</span>) == s3.charAt(p) &amp;&amp; dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j] || (s2.charAt(j - <span class="number">1</span>) == s3.charAt(p) &amp;&amp; dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200718092411513.png" alt="image-20200718092411513"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-167-两数之和Ⅱ</title>
    <url>/2020/07/20/Leetcode-167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%E2%85%A1/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<p>说明:</p>
<p>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>
<p>示例:</p>
<blockquote>
<p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p>
</blockquote>
</blockquote>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>指针<code>i</code>指向第一个元素, 指针<code>j</code>指向最后一个元素.</p>
<p>计算两个指针对应元素之和<code>sum</code>:</p>
<ol>
<li>如果<code>sum</code>大于<code>target</code>, 则需要减小元素之和, 那么<code>j--</code></li>
<li>如果<code>sum</code>小于<code>target</code>, 则需要增加元素之和, 那么<code>i++</code></li>
<li>如果<code>sum</code>等于<code>targe</code>, 则直接返回<code>i+1</code>和<code>j+1</code>(题目要求下标从1开始)</li>
</ol>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) i++;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target) j--;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200720083246426.png" alt="image-20200720083246426"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-220-存在重复元素Ⅲ</title>
    <url>/2020/07/20/Leetcode-220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E2%85%A2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ，且满足 i 和 j 的差的绝对值也小于等于 ķ 。</p>
<p>如果存在则返回 true，不存在返回 false。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: nums = [1,2,3,1], k = 3, t = 0<br>输出: true</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: nums = [1,0,1,1], k = 1, t = 2<br>输出: true</p>
</blockquote>
<p>示例 3:</p>
<blockquote>
<p>输入: nums = [1,5,9,1,5,9], k = 2, t = 3<br>输出: false</p>
</blockquote>
</blockquote>
<h1 id="平衡二叉树-红黑树"><a href="#平衡二叉树-红黑树" class="headerlink" title="平衡二叉树/红黑树"></a>平衡二叉树/红黑树</h1><p><code>Java</code>中的<code>Treeset</code>内部是由红黑树实现的. <code>Treeset.ceiling</code>函数可以寻找特定节点的中序后继, <code>Treeset.floor</code>函数可以寻找特定节点的中序前驱.</p>
<ul>
<li>初始化一颗空的红黑树<code>tree</code></li>
<li>遍历整个数组, 对于每一个元素<code>nums[i]</code>:<ul>
<li>在<code>tree</code>上查找<code>nums[i]</code>的后继<code>s</code>(大于等于<code>nums[i]</code>的最小的数), 如果<code>s-nums[i]&lt;=t</code>, 则返回<code>true</code></li>
<li>在<code>tree</code>上查找<code>nums[i]</code>的前驱<code>g</code>(小于等于<code>nums[i]</code>的最大的数), 如果<code>nums[i] - g&lt;=t</code>, 则返回<code>true</code></li>
<li>在<code>tree</code>中插入<code>nums[i]</code></li>
<li>如果<code>tree</code>的大小超过了<code>k</code>, 则移除最早加入<code>tree</code>的那个数(<code>nums[i-k]</code>)</li>
</ul>
</li>
</ul>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; tree = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            Integer s = tree.ceiling(nums[i]); <span class="comment">// 寻找当前元素的后继</span></span><br><span class="line">            Integer g = tree.floor(nums[i]);  <span class="comment">// 寻找当前元素的前驱</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (s != <span class="keyword">null</span> &amp;&amp; s &lt;= t + nums[i]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (g != <span class="keyword">null</span> &amp;&amp; nums[i] &lt;= t + g) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            tree.add(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (tree.size() &gt; k) &#123;</span><br><span class="line">                tree.remove(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200720181700539.png" alt="image-20200720181700539"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
        <tag>平衡二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-95-不同的二叉搜索树Ⅱ</title>
    <url>/2020/07/21/Leetcode-95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E2%85%A1/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong></p>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200721092547034.png" alt="image-20200721092547034"></p>
</blockquote>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>遍历<code>1...n</code>中的所有元素, 以当前元素为根结点. 计算所有可能的左子树和右子树, 并将所有<strong>左子树-右子树</strong>组合拼接到根结点上.</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; roots = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            roots.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> roots;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; leftTrees = generateTrees(start, i - <span class="number">1</span>);  <span class="comment">// 获取所有可能的左子树</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees = generateTrees(i + <span class="number">1</span>, end);  <span class="comment">// 获取所有可能的右子树</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历所有左子树和右子树的组合, 拼接到根结点上</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode leftTree : leftTrees) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode rightTree : rightTrees) &#123;</span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i, leftTree, rightTree);</span><br><span class="line">                    roots.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roots;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://kpicgo.oss-cn-shanghai.aliyuncs.com/image-20200721092906650.png" alt="image-20200721092906650"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
</search>
